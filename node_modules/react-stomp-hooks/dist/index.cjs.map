{"version":3,"sources":["../src/index.tsx","../src/components/StompSessionProvider.tsx","../src/context/StompContext.tsx","../src/hooks/useSubscription.tsx","../src/hooks/useStompClient.tsx","../src/hoc/withStompClient.tsx","../src/hoc/withSubscription.tsx","../src/mock/index.tsx","../src/mock/subscriptions.tsx","../src/mock/client.tsx","../src/mock/StompSessionProviderMock.tsx","../src/mock/reset.tsx"],"sourcesContent":["import StompSessionProvider from \"./components/StompSessionProvider\";\nimport useSubscription from \"./hooks/useSubscription\";\nimport useStompClient from \"./hooks/useStompClient\";\nimport withStompClient from \"./hoc/withStompClient\";\nimport withSubscription from \"./hoc/withSubscription\";\nimport * as mock from \"./mock/index\";\n\nexport {\n  StompSessionProvider,\n  useSubscription,\n  useStompClient,\n  withStompClient,\n  withSubscription,\n  mock,\n};\n\nexport type {\n  Client,\n  messageCallbackType,\n  IMessage,\n  StompHeaders,\n  StompConfig,\n  IFrame,\n  IPublishParams,\n  IRawFrameType,\n  IStompSocket,\n  IStompSocketMessageEvent,\n  ITransaction,\n  StompSocketState,\n  ActivationState,\n  wsErrorCallbackType,\n  RawHeaderType,\n  closeEventCallbackType,\n  frameCallbackType,\n  debugFnType,\n} from \"@stomp/stompjs\";\n","import { useEffect, useRef, useState } from \"react\";\nimport SockJS from \"sockjs-client/dist/sockjs.min.js\";\nimport {\n  Client,\n  IStompSocket,\n  messageCallbackType,\n  StompHeaders,\n} from \"@stomp/stompjs\";\nimport { StompSessionProviderProps } from \"../interfaces/StompSessionProviderProps\";\nimport { StompSessionSubscription } from \"../interfaces/StompSessionSubscription\";\nimport getStompContext from \"../context/StompContext.tsx\";\n\n/**\n * The StompSessionProvider manages the STOMP connection\n * All Hooks and HOCs in this library require an ancestor of this type.\n * The URL to connect to can be specified via the url prop.\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\n * Custom @stomp/stompjs options can be used as props.\n * Please consult the @stomp/stompjs documentation for more information.\n */\nfunction StompSessionProvider(props: StompSessionProviderProps) {\n  const { url, children, enabled, name, ...stompOptions } = props;\n\n  const StompContext = getStompContext(name || \"default\");\n  const [client, setClient] = useState<Client | undefined>(undefined);\n  const subscriptionRequests = useRef(new Map());\n\n  useEffect(() => {\n    const _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        const parsedUrl = new URL(url, window?.location?.href);\n        if (parsedUrl.protocol === \"http:\" || parsedUrl.protocol === \"https:\") {\n          return new SockJS(url) as IStompSocket;\n        } else if (\n          parsedUrl.protocol === \"ws:\" ||\n          parsedUrl.protocol === \"wss:\"\n        ) {\n          return new WebSocket(url) as IStompSocket;\n        } else throw new Error(\"Protocol not supported\");\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n\n      subscriptionRequests.current.forEach((value) => {\n        value.subscription = _client.subscribe(\n          value.destination,\n          value.callback,\n          value.headers,\n        );\n      });\n\n      setClient(_client);\n    };\n\n    _client.onWebSocketClose = function (event) {\n      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);\n\n      setClient(undefined);\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    if (enabled !== false) {\n      _client.activate();\n    }\n\n    return () => {\n      _client.deactivate();\n    };\n  }, [url, enabled, ...Object.values(stompOptions)]);\n\n  const subscribe = (\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {},\n  ) => {\n    const subscriptionId = Math.random().toString(36).substr(2, 9);\n    const subscriptionRequest: StompSessionSubscription = {\n      destination,\n      callback,\n      headers,\n    };\n\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(\n        destination,\n        callback,\n        headers,\n      );\n    }\n\n    return () => {\n      const subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n\n  return (\n    <StompContext.Provider\n      value={{\n        client,\n        subscribe,\n      }}\n    >\n      {children}\n    </StompContext.Provider>\n  );\n}\n\nexport default StompSessionProvider;\n","import { createContext, Context } from \"react\";\nimport { StompSessionProviderContext } from \"../interfaces/StompSessionProviderContext\";\n\nconst StompContextMap = new Map<\n  string,\n  Context<StompSessionProviderContext | undefined>\n>();\n\nconst getStompContext = (id: string) => {\n  if (StompContextMap.has(id)) {\n    return StompContextMap.get(id) as Context<\n      StompSessionProviderContext | undefined\n    >;\n  }\n\n  const context = createContext<StompSessionProviderContext | undefined>(\n    undefined,\n  );\n\n  StompContextMap.set(id, context);\n\n  return context;\n};\n\nexport default getStompContext;\n","import { useContext, useEffect, useRef } from \"react\";\nimport { messageCallbackType, StompHeaders } from \"@stomp/stompjs\";\nimport getStompContext from \"../context/StompContext.tsx\";\n\n/**\n *\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\n * @param onMessage Callback called when a message arrives for this subscription\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\n * @param name Name of the StompSessionProvider to use. Default is \"default\"\n */\nfunction useSubscription(\n  destinations: string | string[],\n  onMessage: messageCallbackType,\n  headers: StompHeaders = {},\n  name?: string,\n) {\n  const stompContext = useContext(getStompContext(name || \"default\"));\n\n  if (stompContext === undefined)\n    throw new Error(\n      \"There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs\",\n    );\n\n  const callbackRef = useRef<messageCallbackType>(onMessage);\n  const _destinations = Array.isArray(destinations)\n    ? destinations\n    : [destinations];\n\n  callbackRef.current = onMessage;\n\n  useEffect(() => {\n    const cleanUpFunctions: (() => void)[] = [];\n\n    _destinations.forEach((_destination) =>\n      cleanUpFunctions.push(\n        stompContext.subscribe(\n          _destination,\n          (message) => {\n            callbackRef.current(message);\n          },\n          headers,\n        ),\n      ),\n    );\n\n    return () => {\n      cleanUpFunctions.forEach((_cleanUpFunction) => {\n        _cleanUpFunction();\n      });\n    };\n  }, [\n    Object.values(_destinations).toString(),\n    Object.values(headers).toString(),\n  ]);\n}\n\nexport default useSubscription;\n","import { useContext } from \"react\";\nimport { StompSessionProviderContext } from \"../interfaces/StompSessionProviderContext\";\nimport getStompContext from \"../context/StompContext\";\n\n/**\n * Returns the Stomp Client from @stomp/stompjs\n * This will be undefined if the client is currently not connected\n */\nfunction useStompClient(name?: string) {\n  const context = useContext<StompSessionProviderContext | undefined>(\n    getStompContext(name || \"default\"),\n  );\n\n  if (context === undefined)\n    throw new Error(\n      \"There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs\",\n    );\n\n  return context.client;\n}\n\nexport default useStompClient;\n","import React from \"react\";\nimport useStompClient from \"../hooks/useStompClient\";\n\nfunction withStompClient<P>(\n  WrappedComponent: React.ComponentType<P>,\n  name?: string,\n) {\n  const comp = (props: P) => {\n    const stompClient = useStompClient(name);\n    return <WrappedComponent stompClient={stompClient} {...props} />;\n  };\n\n  comp.displayName = `withStompClient(${WrappedComponent.displayName || WrappedComponent.name})`;\n\n  return comp;\n}\n\nexport default withStompClient;\n","import { useRef } from \"react\";\nimport useSubscription from \"../hooks/useSubscription\";\nimport { StompHeaders, IMessage } from \"@stomp/stompjs\";\nimport {\n  MessageReceiverInterface,\n  StompMessageReceiver,\n} from \"../interfaces/StompMessageReceiver\";\n\nfunction withSubscription<P>(\n  WrappedComponent: StompMessageReceiver<P>,\n  destinations: string | string[],\n  headers: StompHeaders = {},\n  name?: string,\n) {\n  const comp = (props: P) => {\n    const ref = useRef<MessageReceiverInterface>();\n    useSubscription(\n      destinations,\n      (message: IMessage) => {\n        if (ref.current) ref.current.onMessage(message);\n      },\n      headers,\n      name,\n    );\n\n    // @ts-expect-error - Ref type incompatible\n    return <WrappedComponent ref={ref} {...props} />;\n  };\n\n  comp.displayName = `withSubscription(${WrappedComponent.displayName || WrappedComponent.name})`;\n\n  return comp;\n}\n\nexport default withSubscription;\n","import StompSessionProviderMock from \"./StompSessionProviderMock\";\nimport {\n  getMockClient,\n  mockClientPublish,\n  getSentMockMessages,\n} from \"./client\";\nimport { mockReceiveMessage, getMockSubscriptions } from \"./subscriptions\";\nimport { reset } from \"./reset\";\n\nexport {\n  StompSessionProviderMock,\n  getMockClient,\n  mockClientPublish,\n  mockReceiveMessage,\n  getSentMockMessages,\n  reset,\n  getMockSubscriptions,\n};\n","import { IMessage } from \"@stomp/stompjs\";\nimport { messageCallbackType, StompHeaders } from \"@stomp/stompjs\";\n\nexport const subscriptions = new Map<\n  string,\n  Map<string, messageCallbackType>\n>();\n\nexport function subscribeMock(\n  destination: string,\n  callback: messageCallbackType,\n  // @ts-expect-error - irrelevant in mock\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  headers: StompHeaders = {},\n) {\n  const subscriptionId = Math.random().toString(36).substr(2, 9);\n\n  if (!subscriptions.has(destination)) {\n    subscriptions.set(destination, new Map<string, messageCallbackType>());\n  }\n\n  // @ts-expect-error undefined check\n  subscriptions.get(destination).set(subscriptionId, callback);\n\n  return () => {\n    // Might be undefined if reset was called before the component unmounted\n    subscriptions.get(destination)?.delete(subscriptionId);\n  };\n}\n\n/**\n * Simulates receiving a message from the server to the specified destination\n * @param destination The topic to send the message to\n * @param message The message to send\n */\nexport function mockReceiveMessage(\n  destination: string,\n  message: IMessage,\n): void {\n  if (subscriptions.has(destination)) {\n    // @ts-expect-error undefined check\n    subscriptions.get(destination).forEach((callback: messageCallbackType) => {\n      callback(message);\n    });\n  }\n}\n\n/**\n * Gets the current subscriptions for the specified destination\n * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions\n */\nexport function getMockSubscriptions(destination?: string) {\n  if (destination) {\n    return subscriptions.get(destination);\n  }\n  return subscriptions;\n}\n","import { IPublishParams } from \"@stomp/stompjs\";\n\nexport const messages = new Map<string, Array<IPublishParams>>();\n\n/**\n * A mock implementation of the publish function of the @stomp/stompjs client.\n * Will store the messages in a map, keyed by the destination.\n * @param params\n */\nexport function mockClientPublish(params: IPublishParams) {\n  if (!messages.has(params.destination)) {\n    messages.set(params.destination, []);\n  }\n\n  // @ts-expect-error - possible undefined\n  messages.get(params.destination).push(params);\n}\n\n/**\n * Gets a default Mock of the @stomp/stompjs client.\n * If you require a custom client, you can use this as a base.\n */\nexport function getMockClient() {\n  return {\n    publish: mockClientPublish,\n  };\n}\n\n/**\n * Gets all messages which have been sent via a mock client.\n * @param destination The destination to get messages for, or undefined to get all messages.\n */\nexport function getSentMockMessages(destination?: string) {\n  if (destination) {\n    return messages.get(destination);\n  }\n  return messages;\n}\n","import React from \"react\";\nimport { subscribeMock } from \"./subscriptions\";\nimport { getMockClient } from \"./client\";\nimport getStompContext from \"../context/StompContext\";\n\n/**\n * A mock StompSessionProvider.\n * Messages send via this mock implementation can be received via the getSentMockMessages method.\n * Subscriptions can be received via the getMockSubscriptions method.\n * The sendMockMessage method can be used, to simulate receiving a message from the server.\n *\n * @param props.client Optional. Can be used to provide a custom mock of the stompjs client,\n * in case you require additional properties/functions to be present. getMockClient can be used as a base.\n * @param props.name Optional. The name of the StompSessionProvider. Default is \"default\"\n * @constructor\n */\nexport default function StompSessionProviderMock(props: {\n  children: React.ReactNode;\n  client?: unknown;\n  name?: string;\n}) {\n  const StompContext = getStompContext(props.name || \"default\");\n\n  return (\n    <StompContext.Provider\n      value={{\n        subscribe: subscribeMock,\n        // @ts-expect-error - Mock client is not a full client\n        client: props.client ?? getMockClient(),\n      }}\n    >\n      {props.children}\n    </StompContext.Provider>\n  );\n}\n","import { subscriptions } from \"./subscriptions\";\nimport { messages } from \"./client\";\n\n/**\n * Resets the state of the mock implementation, clearing all subscriptions and messages.\n */\nexport function reset() {\n  subscriptions.clear();\n  messages.clear();\n}\n"],"mappings":"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","names":["src_exports","__export","StompSessionProvider_default","mock_exports","useStompClient_default","useSubscription_default","withStompClient_default","withSubscription_default","__toCommonJS","import_react","import_sockjs_min","import_stompjs","import_react","StompContextMap","getStompContext","id","context","StompContext_default","import_jsx_runtime","StompSessionProvider","props","url","children","enabled","name","stompOptions","StompContext","StompContext_default","client","setClient","subscriptionRequests","_client","parsedUrl","SockJS","frame","value","event","subscribe","destination","callback","headers","subscriptionId","subscriptionRequest","subscriptionData","StompSessionProvider_default","import_react","useSubscription","destinations","onMessage","headers","name","stompContext","StompContext_default","callbackRef","_destinations","cleanUpFunctions","_destination","message","_cleanUpFunction","useSubscription_default","import_react","useStompClient","name","context","StompContext_default","useStompClient_default","import_jsx_runtime","withStompClient","WrappedComponent","name","comp","props","stompClient","useStompClient_default","withStompClient_default","import_react","import_jsx_runtime","withSubscription","WrappedComponent","destinations","headers","name","comp","props","ref","useSubscription_default","message","withSubscription_default","mock_exports","__export","StompSessionProviderMock","getMockClient","getMockSubscriptions","getSentMockMessages","mockClientPublish","mockReceiveMessage","reset","subscriptions","subscribeMock","destination","callback","headers","subscriptionId","mockReceiveMessage","message","getMockSubscriptions","messages","mockClientPublish","params","getMockClient","getSentMockMessages","destination","import_jsx_runtime","StompSessionProviderMock","props","StompContext","StompContext_default","subscribeMock","getMockClient","reset","subscriptions","messages"]}