var A=Object.defineProperty;var F=(e,t)=>{for(var o in t)A(e,o,{get:t[o],enumerable:!0})};import{useEffect as U,useRef as q,useState as L}from"react";import _ from"sockjs-client/dist/sockjs.min.js";import{Client as $}from"@stomp/stompjs";import{createContext as O}from"react";var C=new Map,N=e=>{if(C.has(e))return C.get(e);let t=O(void 0);return C.set(e,t),t},u=N;import{jsx as j}from"react/jsx-runtime";function D(e){let{url:t,children:o,enabled:n,name:m,...r}=e,a=u(m||"default"),[p,S]=L(void 0),b=q(new Map);U(()=>{let i=new $(r);return!r.brokerURL&&!r.webSocketFactory&&(i.webSocketFactory=function(){let s=new URL(t,window?.location?.href);if(s.protocol==="http:"||s.protocol==="https:")return new _(t);if(s.protocol==="ws:"||s.protocol==="wss:")return new WebSocket(t);throw new Error("Protocol not supported")}),i.onConnect=function(s){r.onConnect&&r.onConnect(s),b.current.forEach(f=>{f.subscription=i.subscribe(f.destination,f.callback,f.headers)}),S(i)},i.onWebSocketClose=function(s){r.onWebSocketClose&&r.onWebSocketClose(s),S(void 0)},r.onStompError||(i.onStompError=function(s){throw s}),n!==!1&&i.activate(),()=>{i.deactivate()}},[t,n,...Object.values(r)]);let H=(i,s,f={})=>{let g=Math.random().toString(36).substr(2,9),M={destination:i,callback:s,headers:f};return b.current.set(g,M),p&&p.connected&&(M.subscription=p.subscribe(i,s,f)),()=>{let v=b.current.get(g);v.subscription&&v.subscription.unsubscribe(),b.current.delete(g)}};return j(a.Provider,{value:{client:p,subscribe:H},children:o})}var J=D;import{useContext as z,useEffect as B,useRef as G}from"react";function K(e,t,o={},n){let m=z(u(n||"default"));if(m===void 0)throw new Error("There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs");let r=G(t),a=Array.isArray(e)?e:[e];r.current=t,B(()=>{let p=[];return a.forEach(S=>p.push(m.subscribe(S,b=>{r.current(b)},o))),()=>{p.forEach(S=>{S()})}},[Object.values(a).toString(),Object.values(o).toString()])}var k=K;import{useContext as Q}from"react";function V(e){let t=Q(u(e||"default"));if(t===void 0)throw new Error("There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs");return t.client}var x=V;import{jsx as Y}from"react/jsx-runtime";function W(e,t){let o=n=>{let m=x(t);return Y(e,{stompClient:m,...n})};return o.displayName=`withStompClient(${e.displayName||e.name})`,o}var X=W;import{useRef as Z}from"react";import{jsx as oe}from"react/jsx-runtime";function ee(e,t,o={},n){let m=r=>{let a=Z();return k(t,p=>{a.current&&a.current.onMessage(p)},o,n),oe(e,{ref:a,...r})};return m.displayName=`withSubscription(${e.displayName||e.name})`,m}var te=ee;var E={};F(E,{StompSessionProviderMock:()=>P,getMockClient:()=>d,getMockSubscriptions:()=>I,getSentMockMessages:()=>R,mockClientPublish:()=>h,mockReceiveMessage:()=>y,reset:()=>T});var c=new Map;function w(e,t,o={}){let n=Math.random().toString(36).substr(2,9);return c.has(e)||c.set(e,new Map),c.get(e).set(n,t),()=>{c.get(e)?.delete(n)}}function y(e,t){c.has(e)&&c.get(e).forEach(o=>{o(t)})}function I(e){return e?c.get(e):c}var l=new Map;function h(e){l.has(e.destination)||l.set(e.destination,[]),l.get(e.destination).push(e)}function d(){return{publish:h}}function R(e){return e?l.get(e):l}import{jsx as re}from"react/jsx-runtime";function P(e){let t=u(e.name||"default");return re(t.Provider,{value:{subscribe:w,client:e.client??d()},children:e.children})}function T(){c.clear(),l.clear()}export{J as StompSessionProvider,E as mock,x as useStompClient,k as useSubscription,X as withStompClient,te as withSubscription};
//# sourceMappingURL=index.js.map